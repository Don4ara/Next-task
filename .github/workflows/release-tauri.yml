name: Release Tauri updates (public repo)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  prepare:
    name: Prepare version & tag
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set.outputs.tag }}
      version: ${{ steps.set.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read version from Tauri config
        id: ver
        run: |
          if [ ! -f src-tauri/tauri.conf.json ]; then
            echo "src-tauri/tauri.conf.json not found"
            exit 1
          fi
          VER=$(jq -r '.version // .app.version // .package.version' src-tauri/tauri.conf.json)
          if [ -z "$VER" ] || [ "$VER" = "null" ]; then
            echo "Version not found in tauri.conf.json"
            exit 1
          fi
          echo "version=$VER" >> $GITHUB_OUTPUT

      - name: Set tag from version (no bump)
        id: set
        run: |
          VERSION="${{ steps.ver.outputs.version }}"
          TAG="v${VERSION}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Will use TAG=${TAG}, VERSION=${VERSION}"

      - name: Create tag if missing (no re-tag)
        run: |
          TAG="${{ steps.set.outputs.tag }}"
          if git ls-remote --tags origin "refs/tags/${TAG}" | grep -q "${TAG}$"; then
            echo "Tag ${TAG} exists — keep it."
          else
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git tag -a "${TAG}" -m "Release ${TAG}"
            git push origin "${TAG}"
          fi

  build:
    name: Build ${{ matrix.os }} • Tauri
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            rust_target: aarch64-apple-darwin
          - os: windows-latest
            rust_target: x86_64-pc-windows-msvc
          - os: ubuntu-latest
            rust_target: x86_64-unknown-linux-gnu

    env:
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
      CI: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install JS deps
        run: npm ci

      - name: Install Linux deps
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libsoup-3.0-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            pkg-config \
            patchelf
          sudo apt-get install -y libwebkit2gtk-4.1-dev || sudo apt-get install -y libwebkit2gtk-4.0-dev

      - name: Build frontend (Next)
        run: npm run build

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        with:
          tagName: ${{ needs.prepare.outputs.tag }}
          releaseName: ${{ needs.prepare.outputs.tag }}
          releaseDraft: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect built artifacts
        shell: bash
        run: |
          set -e
          mkdir -p upload
          # Берём только bundle-артефакты и подписи, исключаем build_script_build*
          find src-tauri/target -type f -path "*/bundle/*" \( \
            -name "*.app.tar.gz" -o \
            -name "*.dmg" -o \
            -name "*.msi" -o \
            -name "*_setup.exe" -o \
            -name "*.AppImage" -o \
            -name "*.deb" -o \
            -name "*.rpm" -o \
            -name "*.zip" -o \
            -name "*.tar.*" -o \
            -name "*.sig" \
          \) ! -name "build_script_build*" \
          -print -exec cp {} upload/ \; || true
          echo "Collected:"
          ls -la upload || true

      - name: Upload artifacts (cross OS)
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ matrix.os }}
          path: upload/

  publish:
    name: Publish to public updates repo
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Generate latest.json
        id: latest
        shell: bash
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          OWNER_REPO: ${{ secrets.UPDATES_REPO }}  # напр. Don4ara/Next-task-updates
        run: |
          set -euo pipefail

          # macOS: предпочтительно .app.tar.gz, иначе .dmg
          MAC_APP_TGZ="$(ls dist/**/**.app.tar.gz 2>/dev/null | head -n1 || true)"
          MAC_APP_TGZ_SIG="$( [ -n "$MAC_APP_TGZ" ] && [ -f "${MAC_APP_TGZ}.sig" ] && cat "${MAC_APP_TGZ}.sig" || true )"
          MAC_DMG="$(ls dist/**/**.dmg 2>/dev/null | head -n1 || true)"
          MAC_DMG_SIG="$( [ -n "$MAC_DMG" ] && [ -f "${MAC_DMG}.sig" ] && cat "${MAC_DMG}.sig" || true )"

          # Windows: сначала MSI, иначе *_setup.exe
          WIN_MSI="$(ls dist/**/**.msi 2>/dev/null | head -n1 || true)"
          WIN_MSI_SIG="$( [ -n "$WIN_MSI" ] && [ -f "${WIN_MSI}.sig" ] && cat "${WIN_MSI}.sig" || true )"
          WIN_EXE="$(ls dist/**/*_setup.exe 2>/dev/null | head -n1 || true)"
          WIN_EXE_SIG="$( [ -n "$WIN_EXE" ] && [ -f "${WIN_EXE}.sig" ] && cat "${WIN_EXE}.sig" || true )"

          # Linux (для апдейта): AppImage
          LNX_APPIMG="$(ls dist/**/**.AppImage 2>/dev/null | head -n1 || true)"
          LNX_APPIMG_SIG="$( [ -n "$LNX_APPIMG" ] && [ -f "${LNX_APPIMG}.sig" ] && cat "${LNX_APPIMG}.sig" || true )"

          BASE_URL="https://github.com/${OWNER_REPO}/releases/download/v${VERSION}"

          PLATFORMS="{}"

          # macOS
          if [ -n "$MAC_APP_TGZ" ] && [ -n "$MAC_APP_TGZ_SIG" ]; then
            MAC_FILE="$(basename "$MAC_APP_TGZ")"
            PL_MAC=$(jq -n --arg sig "$MAC_APP_TGZ_SIG" --arg url "$BASE_URL/$MAC_FILE" \
              '{ "darwin-aarch64": { "signature": $sig, "url": $url } }')
            PLATFORMS=$(jq -n --argjson a "$PLATFORMS" --argjson b "$PL_MAC" '$a + $b')
          elif [ -n "$MAC_DMG" ] && [ -n "$MAC_DMG_SIG" ]; then
            MAC_FILE="$(basename "$MAC_DMG")"
            PL_MAC=$(jq -n --arg sig "$MAC_DMG_SIG" --arg url "$BASE_URL/$MAC_FILE" \
              '{ "darwin-aarch64": { "signature": $sig, "url": $url } }')
            PLATFORMS=$(jq -n --argjson a "$PLATFORMS" --argjson b "$PL_MAC" '$a + $b')
          fi

          # Windows
          if [ -n "$WIN_MSI" ] && [ -n "$WIN_MSI_SIG" ]; then
            WIN_FILE="$(basename "$WIN_MSI")"
            PL_WIN=$(jq -n --arg sig "$WIN_MSI_SIG" --arg url "$BASE_URL/$WIN_FILE" \
              '{ "windows-x86_64": { "signature": $sig, "url": $url } }')
            PLATFORMS=$(jq -n --argjson a "$PLATFORMS" --argjson b "$PL_WIN" '$a + $b')
          elif [ -n "$WIN_EXE" ] && [ -n "$WIN_EXE_SIG" ]; then
            WIN_FILE="$(basename "$WIN_EXE")"
            PL_WIN=$(jq -n --arg sig "$WIN_EXE_SIG" --arg url "$BASE_URL/$WIN_FILE" \
              '{ "windows-x86_64": { "signature": $sig, "url": $url } }')
            PLATFORMS=$(jq -n --argjson a "$PLATFORMS" --argjson b "$PL_WIN" '$a + $b')
          fi

          # Linux
          if [ -n "$LNX_APPIMG" ] && [ -n "$LNX_APPIMG_SIG" ]; then
            LNX_FILE="$(basename "$LNX_APPIMG")"
            PL_LNX=$(jq -n --arg sig "$LNX_APPIMG_SIG" --arg url "$BASE_URL/$LNX_FILE" \
              '{ "linux-x86_64": { "signature": $sig, "url": $url } }')
            PLATFORMS=$(jq -n --argjson a "$PLATFORMS" --argjson b "$PL_LNX" '$a + $b')
          fi

          PUB_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          NOTES="Auto release ${VERSION}"

          jq -n \
            --arg version "$VERSION" \
            --arg notes "$NOTES" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$PLATFORMS" \
            '{ version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms }' > latest.json

          echo "latest.json:"
          cat latest.json

      - name: Prepare release assets folder
        run: |
          mkdir -p public-release
          cp -a dist/*/* public-release/ || true
          cp latest.json public-release/
          ls -la public-release

      - name: Create or update release in public repo
        env:
          GH_TOKEN: ${{ secrets.UPDATES_TOKEN }}   # PAT к публичному репо
          OWNER_REPO: ${{ secrets.UPDATES_REPO }}  # например Don4ara/Next-task-updates
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail
          gh release create "v${VERSION}" \
            --repo "$OWNER_REPO" \
            --title "v${VERSION}" \
            --notes "Auto-published from private repo" \
            || true

          for f in public-release/*; do
            gh release upload "v${VERSION}" "$f" --repo "$OWNER_REPO" --clobber
            echo "Uploaded: $(basename "$f")"
          done

      - name: Show public latest.json URL
        env:
          OWNER_REPO: ${{ secrets.UPDATES_REPO }}
        run: |
          echo "https://github.com/${OWNER_REPO}/releases/latest/download/latest.json"
