name: Release Tauri updates (public repo)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write   # нужно, чтобы создать/запушить теги и релиз в этом (приватном) репо

jobs:
  prepare:
    name: Prepare version & tag
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set.outputs.tag }}
      version: ${{ steps.set.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # нужно, чтобы видеть теги/историю

      - name: Read base version from package.json
        id: ver
        run: |
          if [ ! -f package.json ]; then
            echo "package.json not found. Put version there or tweak this step."
            exit 1
          fi
          BASE_VER=$(jq -r '.version' package.json)
          if [ "$BASE_VER" = "null" ] || [ -z "$BASE_VER" ]; then
            echo "version not found in package.json"
            exit 1
          fi
          echo "base=$BASE_VER" >> $GITHUB_OUTPUT

      - name: Compute next tag (auto-bump patch if exists)
        id: set
        run: |
          BASE="${{ steps.ver.outputs.base }}"
          MAJOR=$(echo "$BASE" | cut -d. -f1)
          MINOR=$(echo "$BASE" | cut -d. -f2)
          PATCH=$(echo "$BASE" | cut -d. -f3)

          TAG="v${BASE}"

          # если тег уже есть в удалённом
          if git ls-remote --tags origin "refs/tags/${TAG}" | grep -q "${TAG}$"; then
            NEXT_PATCH=$((PATCH + 1))
            VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}"
            TAG="v${VERSION}"
          else
            VERSION="${BASE}"
          fi

          echo "Will use TAG=${TAG}, VERSION=${VERSION}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Create and push tag (if not exists)
        run: |
          TAG="${{ steps.set.outputs.tag }}"
          if git ls-remote --tags origin "refs/tags/${TAG}" | grep -q "${TAG}$"; then
            echo "Tag ${TAG} already exists (either base or bumped) — skip creating."
          else
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git tag -a "${TAG}" -m "Auto tag ${TAG} (CI)"
            git push origin "${TAG}"
          fi

  build:
    name: Build ${{ matrix.os }} • Tauri
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            rust_target: aarch64-apple-darwin
          - os: windows-latest
            rust_target: x86_64-pc-windows-msvc
          - os: ubuntu-latest
            rust_target: x86_64-unknown-linux-gnu

    env:
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
      CI: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install JS deps
        run: npm ci

      - name: Build frontend (Next)
        run: npm run build

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        with:
          tagName: ${{ needs.prepare.outputs.tag }}
          releaseName: ${{ needs.prepare.outputs.tag }}
          releaseDraft: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect built artifacts
        shell: bash
        run: |
          mkdir -p upload
          find src-tauri/target -maxdepth 4 -type f \( \
            -name "*.dmg" -o -name "*.msi" -o -name "*.exe" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.tar.*" -o -name "*.zip" -o -name "*.sig" \
          \) -print -exec cp {} upload/ \; || true
          echo "Collected:"
          ls -la upload || true

      - name: Upload artifacts (cross OS)
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ matrix.os }}
          path: upload/

  publish:
    name: Publish to public updates repo
    needs: [prepare, build]
    runs-on: ubuntu-latest

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Show tree
        run: ls -laR dist

      - name: Generate latest.json
        id: latest
        shell: bash
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          OWNER_REPO: ${{ secrets.UPDATES_REPO }}  # напр. Don4ara/Next-task-updates
        run: |
          set -euo pipefail

          MAC_DMG="$(ls dist/**/**.dmg 2>/dev/null | head -n1 || true)"
          WIN_MSI="$(ls dist/**/**.msi 2>/dev/null | head -n1 || true)"
          LNX_APPIMG="$(ls dist/**/**.AppImage 2>/dev/null | head -n1 || true)"

          MAC_SIG="$( [ -n "$MAC_DMG" ] && [ -f "$MAC_DMG.sig" ] && cat "$MAC_DMG.sig" || true )"
          WIN_SIG="$( [ -n "$WIN_MSI" ] && [ -f "$WIN_MSI.sig" ] && cat "$WIN_MSI.sig" || true )"
          LNX_SIG="$( [ -n "$LNX_APPIMG" ] && [ -f "$LNX_APPIMG.sig" ] && cat "$LNX_APPIMG.sig" || true )"

          BASE_URL="https://github.com/${OWNER_REPO}/releases/download/v${VERSION}"
          MAC_FILE="$( [ -n "$MAC_DMG" ] && basename "$MAC_DMG" || true )"
          WIN_FILE="$( [ -n "$WIN_MSI" ] && basename "$WIN_MSI" || true )"
          LNX_FILE="$( [ -n "$LNX_APPIMG" ] && basename "$LNX_APPIMG" || true )"

          PLATFORMS="{}"
          if [ -n "$MAC_FILE" ] && [ -n "$MAC_SIG" ]; then
            PLATFORMS=$(jq -n --arg sig "$MAC_SIG" --arg url "$BASE_URL/$MAC_FILE" \
              '{ "darwin-aarch64": { "signature": $sig, "url": $url } }')
          fi
          if [ -n "$WIN_FILE" ] && [ -n "$WIN_SIG" ]; then
            PL_WIN=$(jq -n --arg sig "$WIN_SIG" --arg url "$BASE_URL/$WIN_FILE" \
              '{ "windows-x86_64": { "signature": $sig, "url": $url } }')
            PLATFORMS=$(jq -n --argjson a "$PLATFORMS" --argjson b "$PL_WIN" '$a + $b')
          fi
          if [ -n "$LNX_FILE" ] && [ -n "$LNX_SIG" ]; then
            PL_LNX=$(jq -n --arg sig "$LNX_SIG" --arg url "$BASE_URL/$LNX_FILE" \
              '{ "linux-x86_64": { "signature": $sig, "url": $url } }')
            PLATFORMS=$(jq -n --argjson a "$PLATFORMS" --argjson b "$PL_LNX" '$a + $b')
          fi

          PUB_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          NOTES="Auto release ${VERSION}"

          jq -n \
            --arg version "$VERSION" \
            --arg notes "$NOTES" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$PLATFORMS" \
            '{ version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms }' > latest.json

          echo "latest.json:"
          cat latest.json

      - name: Prepare release assets folder
        run: |
          mkdir -p public-release
          cp -a dist/*/* public-release/ || true
          cp latest.json public-release/
          ls -la public-release

      - name: Create or update release in public repo
        env:
          GH_TOKEN: ${{ secrets.UPDATES_TOKEN }}   # PAT к публичному репо-«апдейтеру»
          OWNER_REPO: ${{ secrets.UPDATES_REPO }}  # например Don4ara/Next-task-updates
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail
          gh release create "v${VERSION}" \
            --repo "$OWNER_REPO" \
            --title "v${VERSION}" \
            --notes "Auto-published from private repo" \
            || true

          for f in public-release/*; do
            gh release upload "v${VERSION}" "$f" --repo "$OWNER_REPO" --clobber
            echo "Uploaded: $(basename "$f")"
          done

      - name: Show public latest.json URL
        env:
          OWNER_REPO: ${{ secrets.UPDATES_REPO }}
        run: |
          echo "https://github.com/${OWNER_REPO}/releases/latest/download/latest.json"
